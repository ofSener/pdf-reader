# Worker Pool, Redis ve Load Balancing Kƒ±lavuzu

Bu dok√ºmantasyon, PDF Reader API'sinin production ortamƒ±nda y√ºksek y√ºk altƒ±nda √ßalƒ±≈üabilmesi i√ßin **Worker Pool**, **Redis Queue** ve **Load Balancing** yapƒ±landƒ±rmasƒ±nƒ± a√ßƒ±klar.

## üìä Mevcut Durum vs ƒ∞deal Mimari

### ≈ûu Anki Mimari (Mevcut Kod)

```
Client ‚Üí HTTP Request ‚Üí API Controller ‚Üí Task.WhenAll (Paralel)
                                              ‚Üì
                                    HTTP Response (blocking)
```

**Sorunlar:**
- ‚ùå Client 10 dakika boyunca beklemek zorunda (timeout)
- ‚ùå Sunucu restart olursa i≈ülemler kaybolur
- ‚ùå Load balancing yapƒ±lamaz
- ‚ùå Progress tracking yok
- ‚ùå Retry mekanizmasƒ± yok

### ƒ∞deal Mimari (√ñnerilen)

```
Client ‚Üí HTTP Request ‚Üí Job ID d√∂nd√ºr (hemen)
              ‚Üì
         Redis Queue
              ‚Üì
    Background Worker Pool
              ‚Üì
    Results ‚Üí Redis Cache
              ‚Üì
Client ‚Üí GET /api/job/{id} ‚Üí Result
```

**Avantajlar:**
- ‚úÖ Client hemen response alƒ±r
- ‚úÖ ƒ∞≈ülemler background'da devam eder
- ‚úÖ Sunucu restart olsa bile i≈ülemler kaybolmaz
- ‚úÖ Progress tracking yapƒ±labilir
- ‚úÖ Retry mekanizmasƒ± eklenebilir
- ‚úÖ Horizontal scaling yapƒ±labilir (multiple workers)

---

## üéØ ƒ∞mplementasyon Se√ßenekleri

### Se√ßenek 1: Hangfire + Redis (√ñNERƒ∞LEN)

**Kullanƒ±m Senaryosu:** Production, y√ºksek y√ºk, enterprise √ß√∂z√ºm

**Avantajlar:**
- ‚úÖ Ready-to-use dashboard
- ‚úÖ Retry mekanizmasƒ± built-in
- ‚úÖ Recurring jobs desteƒüi
- ‚úÖ Redis persistence
- ‚úÖ Distributed locking

**Kurulum:**

#### 1. NuGet Paketleri

```bash
dotnet add package Hangfire.Core --version 1.8.14
dotnet add package Hangfire.AspNetCore --version 1.8.14
dotnet add package Hangfire.Redis.StackExchange --version 1.10.2
dotnet add package StackExchange.Redis --version 2.7.33
```

#### 2. appsettings.json G√ºncellemesi

```json
{
  "ConnectionStrings": {
    "Redis": "localhost:6379,abortConnect=false"
  },
  "Hangfire": {
    "WorkerCount": 8,
    "PollingInterval": "00:00:01"
  }
}
```

#### 3. Program.cs G√ºncellemesi

```csharp
using Hangfire;
using Hangfire.Redis.StackExchange;

// Redis connection
var redisConnection = ConnectionMultiplexer.Connect(
    builder.Configuration.GetConnectionString("Redis") ?? "localhost:6379");

// Hangfire configuration
builder.Services.AddHangfire(config => config
    .SetDataCompatibilityLevel(CompatibilityLevel.Version_180)
    .UseSimpleAssemblyNameTypeSerializer()
    .UseRecommendedSerializerSettings()
    .UseRedisStorage(redisConnection, new RedisStorageOptions
    {
        Prefix = "hangfire:pdfreader:",
        InvisibilityTimeout = TimeSpan.FromMinutes(30)
    }));

builder.Services.AddHangfireServer(options =>
{
    options.WorkerCount = 8; // CPU core sayƒ±sƒ±na g√∂re ayarlayƒ±n
    options.SchedulePollingInterval = TimeSpan.FromSeconds(1);
    options.ServerName = Environment.MachineName;
});

// Batch processing job servis
builder.Services.AddScoped<BatchProcessingJobService>();

var app = builder.Build();

// Hangfire Dashboard (production'da authentication ekleyin!)
app.UseHangfireDashboard("/hangfire", new DashboardOptions
{
    Authorization = new[] { new HangfireAuthorizationFilter() }
});

app.Run();

// Simple authorization filter (production'da ger√ßek auth kullanƒ±n)
public class HangfireAuthorizationFilter : IDashboardAuthorizationFilter
{
    public bool Authorize(DashboardContext context)
    {
        // TODO: Production'da ger√ßek authentication ekleyin
        var httpContext = context.GetHttpContext();
        return httpContext.Request.IsLocal(); // Sadece localhost'tan eri≈üim
    }
}
```

#### 4. Yeni Controller Endpoint'leri

**PolicyController.cs** i√ßine ekleyin:

```csharp
using Hangfire;
using StackExchange.Redis;

private readonly IBackgroundJobClient _backgroundJobs;
private readonly IConnectionMultiplexer _redis;

public PolicyController(
    // ... mevcut parametreler
    IBackgroundJobClient backgroundJobs,
    IConnectionMultiplexer redis)
{
    // ... mevcut kod
    _backgroundJobs = backgroundJobs;
    _redis = redis;
}

/// <summary>
/// Batch i≈ülemi i√ßin job olu≈üturur (asenkron - hemen d√∂ner)
/// </summary>
[HttpPost("extract-batch-async")]
[Consumes("multipart/form-data")]
public async Task<ActionResult<BatchJobResponse>> ExtractPolicyBatchAsync([FromForm] List<IFormFile> files)
{
    try
    {
        if (files == null || files.Count == 0)
            return BadRequest("En az bir dosya y√ºklenmelidir");

        if (files.Count > 100)
            return BadRequest("Maksimum 100 dosya aynƒ± anda i≈ülenebilir");

        // Job ID olu≈ütur
        var jobId = Guid.NewGuid().ToString();

        // Dosyalarƒ± byte array'e √ßevir (Redis'e kaydedilecek)
        var fileData = new List<(string fileName, byte[] fileBytes)>();
        foreach (var file in files)
        {
            using var ms = new MemoryStream();
            await file.CopyToAsync(ms);
            fileData.Add((file.FileName, ms.ToArray()));
        }

        // Hangfire job'ƒ± kuyruƒüa ekle
        var hangfireJobId = _backgroundJobs.Enqueue<BatchProcessingJobService>(
            service => service.ProcessBatchAsync(jobId, fileData, null));

        _logger.LogInformation($"Batch job olu≈üturuldu: {jobId} (Hangfire: {hangfireJobId})");

        // Client'a hemen yanƒ±t d√∂n
        return Ok(new BatchJobResponse
        {
            JobId = jobId,
            Status = "queued",
            TotalFiles = files.Count,
            Message = "ƒ∞≈ülem kuyruƒüa eklendi. Sonu√ßlarƒ± /api/policy/job/{jobId} endpoint'inden takip edebilirsiniz.",
            EstimatedCompletionTime = DateTime.UtcNow.AddSeconds(files.Count * 0.5) // ~500ms/dosya
        });
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Batch job olu≈üturma hatasƒ±");
        return StatusCode(500, $"Job olu≈üturma hatasƒ±: {ex.Message}");
    }
}

/// <summary>
/// Job durumunu ve sonucunu getirir
/// </summary>
[HttpGet("job/{jobId}")]
public async Task<ActionResult<BatchJobStatusResponse>> GetJobStatus(string jobId)
{
    try
    {
        var db = _redis.GetDatabase();

        // Redis'ten job bilgisini al
        var statusKey = $"job:{jobId}:status";
        var resultKey = $"job:{jobId}:result";

        var status = await db.StringGetAsync(statusKey);
        if (status.IsNullOrEmpty)
            return NotFound($"Job bulunamadƒ±: {jobId}");

        var response = new BatchJobStatusResponse
        {
            JobId = jobId,
            Status = status.ToString()
        };

        // Eƒüer tamamlandƒ±ysa sonucu getir
        if (status == "completed")
        {
            var resultJson = await db.StringGetAsync(resultKey);
            if (!resultJson.IsNullOrEmpty)
            {
                response.Result = System.Text.Json.JsonSerializer.Deserialize<BatchExtractionResult>(resultJson!);
            }
        }

        // Progress bilgisini getir
        var progressKey = $"job:{jobId}:progress";
        var progressJson = await db.StringGetAsync(progressKey);
        if (!progressJson.IsNullOrEmpty)
        {
            response.Progress = System.Text.Json.JsonSerializer.Deserialize<BatchProgressInfo>(progressJson!);
        }

        return Ok(response);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, $"Job status getirme hatasƒ±: {jobId}");
        return StatusCode(500, $"Status getirme hatasƒ±: {ex.Message}");
    }
}

// Response modelleri
public class BatchJobResponse
{
    public string JobId { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public int TotalFiles { get; set; }
    public string Message { get; set; } = string.Empty;
    public DateTime EstimatedCompletionTime { get; set; }
}

public class BatchJobStatusResponse
{
    public string JobId { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty; // queued, processing, completed, failed
    public BatchProgressInfo? Progress { get; set; }
    public BatchExtractionResult? Result { get; set; }
}
```

#### 5. BatchProcessingJobService G√ºncellemesi

`ProcessBatchAsync` metodunu Redis ile entegre edin:

```csharp
// Redis'e progress yaz
if (progress != null)
{
    var db = redis.GetDatabase();
    await db.StringSetAsync(
        $"job:{jobId}:progress",
        JsonSerializer.Serialize(progressInfo),
        TimeSpan.FromHours(24));
}

// ƒ∞≈ülem tamamlandƒ±ƒüƒ±nda Redis'e yaz
await db.StringSetAsync($"job:{jobId}:status", "completed");
await db.StringSetAsync(
    $"job:{jobId}:result",
    JsonSerializer.Serialize(result),
    TimeSpan.FromDays(7)); // 7 g√ºn saklansƒ±n
```

---

### Se√ßenek 2: .NET Background Service + Channels (Basit)

**Kullanƒ±m Senaryosu:** Basit projeler, Redis olmadan √ßalƒ±≈üma

**Avantajlar:**
- ‚úÖ Ek dependency yok
- ‚úÖ Kolay implementasyon
- ‚ùå Sunucu restart'ta i≈ülemler kaybolur
- ‚ùå Dashboard yok

**Implementasyon:**

```csharp
// Services/BackgroundBatchProcessor.cs
public class BackgroundBatchProcessor : BackgroundService
{
    private readonly Channel<BatchJob> _channel;

    public BackgroundBatchProcessor()
    {
        _channel = Channel.CreateUnbounded<BatchJob>();
    }

    public void QueueJob(BatchJob job)
    {
        _channel.Writer.TryWrite(job);
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await foreach (var job in _channel.Reader.ReadAllAsync(stoppingToken))
        {
            // Process job
            await ProcessBatchJob(job);
        }
    }
}
```

---

## üîÑ Load Balancing Yapƒ±landƒ±rmasƒ±

### IIS Application Request Routing (ARR)

**Senaryo:** Tek Windows Server, multiple app instance'lar

```powershell
# IIS ARR kurulumu
# https://www.iis.net/downloads/microsoft/application-request-routing

# Web Farm olu≈ütur
New-WebFarm -Name "PdfReaderFarm"
Add-WebFarmServer -Name "PdfReaderFarm" -Address "localhost" -HttpPort 5001
Add-WebFarmServer -Name "PdfReaderFarm" -Address "localhost" -HttpPort 5002
Add-WebFarmServer -Name "PdfReaderFarm" -Address "localhost" -HttpPort 5003
```

### Nginx Load Balancer (Linux/Docker)

```nginx
upstream pdfreader_backend {
    least_conn; # Load balancing algoritmasƒ±

    server pdfreader1:5000 weight=1;
    server pdfreader2:5000 weight=1;
    server pdfreader3:5000 weight=1;
}

server {
    listen 80;
    server_name api.example.com;

    location / {
        proxy_pass http://pdfreader_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
```

### Azure Load Balancer + App Service

```bash
# Azure App Service Scale Out
az appservice plan update \
    --name PdfReaderPlan \
    --resource-group PdfReaderRG \
    --number-of-workers 3

# Auto-scaling kuralƒ±
az monitor autoscale create \
    --resource-group PdfReaderRG \
    --resource PdfReaderApp \
    --min-count 2 \
    --max-count 10 \
    --count 3
```

---

## üìà Performance Test Senaryolarƒ±

### Senaryo 1: 100 PDF Batch (Mevcut Kod)

```bash
# Test scripti
time curl -X POST "http://localhost:5109/api/policy/extract-batch" \
  -H "Content-Type: multipart/form-data" \
  -F "files=@file1.pdf" \
  ... (100 files)

# Beklenen: ~10-15 saniye (4-core CPU)
# Problem: Client beklemek zorunda
```

### Senaryo 2: 100 PDF Batch (Hangfire + Redis)

```bash
# 1. Job olu≈ütur (hemen d√∂ner)
RESPONSE=$(curl -X POST "http://localhost:5109/api/policy/extract-batch-async" \
  -H "Content-Type: multipart/form-data" \
  -F "files=@file1.pdf" \
  ... (100 files))

JOB_ID=$(echo $RESPONSE | jq -r '.jobId')
echo "Job ID: $JOB_ID"

# 2. Status'u takip et
while true; do
  STATUS=$(curl "http://localhost:5109/api/policy/job/$JOB_ID" | jq -r '.status')
  echo "Status: $STATUS"

  if [ "$STATUS" == "completed" ]; then
    break
  fi

  sleep 2
done

# 3. Sonucu al
curl "http://localhost:5109/api/policy/job/$JOB_ID" | jq '.result'
```

---

## üîß Redis Kurulumu

### Windows Server

```powershell
# 1. Redis for Windows (Memurai - Redis uyumlu)
# https://www.memurai.com/get-memurai

# 2. ƒ∞ndir ve kur
.\memurai-setup.exe /quiet

# 3. Servisi ba≈ülat
Start-Service Memurai

# 4. Test et
redis-cli ping
# Yanƒ±t: PONG
```

### Docker (Geli≈ütirme)

```bash
# Redis container ba≈ülat
docker run -d \
  --name redis-pdfreader \
  -p 6379:6379 \
  redis:7-alpine \
  redis-server --appendonly yes

# Test et
docker exec -it redis-pdfreader redis-cli ping
```

### Azure Redis Cache (Production)

```bash
az redis create \
  --name pdfreader-redis \
  --resource-group PdfReaderRG \
  --location westeurope \
  --sku Standard \
  --vm-size c1

# Connection string al
az redis list-keys \
  --name pdfreader-redis \
  --resource-group PdfReaderRG
```

---

## üéØ √ñnerilen Yapƒ±landƒ±rma (Production)

### K√º√ß√ºk/Orta √ñl√ßekli Sistem (< 1000 PDF/saat)

```
1x Windows Server 2022 (8 vCore, 16GB RAM)
1x Redis instance (2GB RAM)
IIS + Hangfire (8 worker)
```

**Maliyet:** ~$200-300/ay (Azure)

### B√ºy√ºk √ñl√ßekli Sistem (> 5000 PDF/saat)

```
3x Windows Server 2022 (16 vCore, 32GB RAM)
1x Azure Redis Cache (Standard C2 - 6GB)
Azure Load Balancer
Hangfire (16 worker x 3 = 48 worker)
```

**Maliyet:** ~$1000-1500/ay (Azure)

---

## üìä Monitoring ve Dashboard

### Hangfire Dashboard

```
http://your-api.com/hangfire

- Job queue g√∂r√ºnt√ºleme
- Ba≈üarƒ±lƒ±/ba≈üarƒ±sƒ±z i≈ülemler
- Retry mekanizmasƒ±
- Real-time statistics
```

### Redis Monitoring

```bash
# Redis CLI ile monitoring
redis-cli --stat

# Memory kullanƒ±mƒ±
redis-cli INFO memory

# Queue uzunluƒüu
redis-cli LLEN hangfire:pdfreader:queue:default
```

### Application Insights (Azure)

```csharp
builder.Services.AddApplicationInsightsTelemetry();

// Custom metrics
telemetryClient.TrackMetric("BatchProcessing.Duration", duration);
telemetryClient.TrackMetric("BatchProcessing.SuccessRate", successRate);
```

---

## ‚ùì SSS (Sƒ±k Sorulan Sorular)

### S1: Redis olmadan kullanabilir miyim?

**C:** Evet, .NET Channels + Background Service kullanabilirsiniz ancak:
- Sunucu restart'ta i≈ülemler kaybolur
- Distributed processing yapƒ±lamaz
- Persistence yok

### S2: Ka√ß worker kullanmalƒ±yƒ±m?

**C:** CPU core sayƒ±sƒ± ile ba≈ülayƒ±n:
- 4 core ‚Üí 4-8 worker
- 8 core ‚Üí 8-16 worker
- 16 core ‚Üí 16-32 worker

### S3: Redis memory ne kadar olmalƒ±?

**C:** Job boyutuna g√∂re:
- 100 PDF batch, her biri 1MB ‚Üí ~100MB RAM
- 1000 job/g√ºn ‚Üí ~2-4GB RAM yeterli

### S4: Hangfire vs Custom Background Service?

**C:**
- **Hangfire**: Production-ready, dashboard, retry, monitoring
- **Custom**: Basit projeler, ek dependency istemeyenler

---

## üöÄ Sonu√ß ve Tavsiye

**Sizin senaryonuz i√ßin:**

1. ‚úÖ **Hangfire + Redis** kullanƒ±n
2. ‚úÖ Windows Server'a **Memurai** (Redis) kurun
3. ‚úÖ IIS'te **8 worker** ile ba≈ülayƒ±n
4. ‚úÖ `/hangfire` dashboard'u monitoring i√ßin kullanƒ±n
5. ‚úÖ Production'da **load balancer** ekleyin (opsiyonel)

**ƒ∞mplementasyon sƒ±rasƒ±:**
1. Redis kur ‚Üí Test et
2. Hangfire NuGet paketlerini ekle
3. Program.cs'yi g√ºncelle
4. BatchProcessingJobService'i entegre et
5. Yeni endpoint'leri test et
6. Dashboard'u monitoring i√ßin kullan

ƒ∞htiyacƒ±nƒ±za g√∂re bu guide'ƒ± takip edebilirsiniz. Detaylƒ± sorularƒ±nƒ±z i√ßin hazƒ±rƒ±m!
